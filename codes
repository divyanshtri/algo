//Randomized quick sort
#include <bits/stdc++.h>
using namespace std;

int partition(int arr[], int low, int high){
    int i=low-1; 
    int pivot=arr[high];
    for(int j=low; j<high; j++){
        if(arr[j]<=pivot){
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i+1], arr[high]);
    return i+1;
}

int randomized(int arr[], int low, int high){
    int randomindex=low + rand() % (high - low + 1);
    swap(arr[randomindex], arr[high]);
    return partition(arr, low, high);
}

void quicksort(int arr[], int low, int high){
    if(low<high){
        int pi=partition(arr, low, high);
        quicksort(arr, low, pi-1);
        quicksort(arr, pi+1, high);
    }
}

int main(){
    int arr[]={4,1,3,2,5};
    srand(time(0));
    quicksort(arr, 0, 4);
    cout<<"After sorting: ";
    for(int i=0; i<5; i++){
        cout<<arr[i]<<" ";
    }
}


//Randomized selection sort

#include <bits/stdc++.h>
using namespace std;

void randss(int arr[], int n){
    srand(time(0));
    for(int i=0; i<n-1; i++){
        int r=i+rand()%(n-i);
        swap(arr[i], arr[r]);
        int min=i;
        for(int j=i+1; j<n; j++){
            if(arr[j]<arr[min]){
                min=j;
            }
        }swap(arr[i], arr[min]);
    }
}

int main(){
    int arr[]={3,21,23,8,16};
    srand(time(0));
    randss(arr, 5);
    cout<<"after sorting: ";
    for(int i=0; i<5; i++){
        cout<<arr[i]<<" ";
    }
}




//KMP string matching algorithm


#include <iostream>
#include <vector>
using namespace std;

//computing Longest Path Suffix table
void computeLPS(string pattern, vector<int>& lps) {
    int m = pattern.length();
    int len = 0;  // length of the previous longest prefix suffix
    lps[0] = 0;   // lps[0] is always 0
    int i = 1;

    while (i < m) {
        if (pattern[i] == pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0)
                len = lps[len - 1];  // fall back
            else {
                lps[i] = 0;
                i++;
            }
        }
    }
}

// KMP search algorithm
void KMPsearch(string text, string pattern) {
    int n = text.length();
    int m = pattern.length();

    vector<int> lps(m);
    computeLPS(pattern, lps); 

    int i = 0; 
    int j = 0; 

    while (i < n) {
        if (pattern[j] == text[i]) {
            i++;
            j++;
        }

        if (j == m) {
            cout << "Pattern found at index " << i - j << endl;
            j = lps[j - 1]; 
        }

        else if (i < n && pattern[j] != text[i]) {
            if (j != 0)
                j = lps[j - 1];
            else
                i++;
        }
    }
}

int main() {
    string text = "ABABDABACDABABCABAB";
    string pattern = "ABABCABAB";

    cout << "Text: " << text << endl;
    cout << "Pattern: " << pattern << endl;

    KMPsearch(text, pattern);

    return 0;
}


//Kruskalâ€™s algorithm


#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

bool cmp(vector<int> &a, vector<int> &b) {
    return a[2] < b[2];
}

void makeset(vector<int> &parent, vector<int> &rank, int n) {
    for (int i = 1; i < n; i++) {
        parent[i] = i;
        rank[i] = 0;
    }
}

int findparent(vector<int> &parent, int node) {
    if (parent[node] == node)  
        return node;
    return parent[node] = findparent(parent, parent[node]);
}

void unionset(int u, int v, vector<int> &parent, vector<int> &rank) {
    u = findparent(parent, u);
    v = findparent(parent, v);

    if (rank[u] < rank[v]) {
        parent[u] = v;
    } else if (rank[v] < rank[u]) {
        parent[v] = u;
    } else {
        parent[v] = u;
        rank[u]++;
    }
}

int minimumspanningtree(vector<vector<int>> &edges, int n) {
    sort(edges.begin(), edges.end(), cmp);

    vector<int> parent(n+1);
    vector<int> rank(n+1);
    makeset(parent, rank, n);

    int minweight = 0;

    for (int i = 0; i < edges.size(); i++) {
        int u = findparent(parent, edges[i][0]);
        int v = findparent(parent, edges[i][1]);
        int wt = edges[i][2];

        if (u != v) {
            minweight += wt;
            unionset(u, v, parent, rank);
        }
    }
    return minweight;
}

int main() {
    int n, e;
    cout << "Enter number of vertices: ";
    cin >> n;

    cout << "Enter number of edges: ";
    cin >> e;

    vector<vector<int>> edges;
    cout << "Enter edges in the format: u v weight\n";

    for (int i = 0; i < e; i++) {
        int u, v, w;
        cout << "Edge " << i + 1 << ": ";
        cin >> u >> v >> w;
        edges.push_back({u, v, w});
    }

    int mstWeight = minimumspanningtree(edges, n);
    cout << "\nTotal Minimum Spanning Tree weight = " << mstWeight << endl;

    return 0;
}


//Bellman ford algorithm

#include <bits/stdc++.h>
using namespace std;

int bellmanford(int n, int m, int src, int dest, vector<vector<int>> &edges){
    vector<int> dist(n+1, 1e9);
    dist[src]=0;

    for(int i=1; i<=n; i++){
        //traverse on edges
        for(int j=0; j<m; j++){
            int u=edges[j][0];
            int v=edges[j][1];
            int wt=edges[j][2];

            if(dist[u]!=1e9 && (dist[u]+wt)<dist[v]){
                dist[v]=dist[u]+wt;
            }
        }
    }

    //check for negative cycle
    bool flag=0;
    for(int j=0; j<m; j++){
            int u=edges[j][0];
            int v=edges[j][1];
            int wt=edges[j][2];

            if(dist[u]!=1e9 && (dist[u]+wt)<dist[v]){
                flag=1;
            }
        }
    if(flag==0){
        return dist[dest];
    }else{
        return -1;
    }
}

int main() {
    int n, m;
    cout << "Enter number of vertices: ";
    cin >> n;

    cout << "Enter number of edges: ";
    cin >> m;

    vector<vector<int>> edges;  
    cout << "Enter edges in format: u v weight\n";

    for(int i = 0; i < m; i++){
        int u, v, w;
        cout << "Edge " << i+1 << ": ";
        cin >> u >> v >> w;
        edges.push_back({u, v, w});
    }

    int src, dest;
    cout << "\nEnter source vertex: ";
    cin >> src;
    cout << "Enter destination vertex: ";
    cin >> dest;

    int result = bellmanford(n, m, src, dest, edges);

    if(result != -1)
        cout << "\nShortest distance from " << src << " to " << dest << " = " << result << endl;

    return 0;
}

